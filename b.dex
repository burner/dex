%%
dchar eolChar() const {
	return '\r';
}

dchar eofChar() const {
	return dchar.init;
}
%%

{%
					if(currentInputChar == ' ' || currentInputChar == '\r' 
							|| currentInputChar == '\n') {
						currentState = 0;
						needToGetNextChar = true;
						needToGetNextState = true;
					} else {
						printfln("lex error at character %d of line %d in file %s",
								this.getCurrentIndexInLine(),
								this.getCurrentLineCount(),
								this.getFilename());
						assert(false, "Lex error");
					}
%}

"[:digit:][:digit:_]*" {: printfln("int %s", this.getCurrentLex()); :}
"0x[01234567][01234567_]*" {: printfln("hex %s", this.getCurrentLex()); :}
"0b[01][01_]*" {: printfln("bin %s", this.getCurrentLex()); :}
"long" {: printfln("long keyword"); :}
"if" {: printfln("if keyword"); :}
"for" {: printfln("for keyword"); :}
"while" {: printfln("while keyword"); :}
"do" {: printfln("do keyword"); :}
"int" {: printfln("int keyword"); :}
"void" {: printfln("void keyword"); :}
"delegate" {: printfln("delegate keyword"); :}
"function" {: printfln("function keyword"); :}
"template" {: printfln("template keyword"); :}
"[:alpha:][:word:]*" {: printfln("identifer"); :}
