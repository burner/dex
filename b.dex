%%
dchar eolChar() const {
	return '\r';
}

dchar eofChar() const {
	return dchar.init;
}
%%

{%
	if(currentInputChar == ' ' || currentInputChar == '\r' 
			|| currentInputChar == '\n') {
		currentState = 0;
		needToGetNextChar = true;
		needToGetNextState = true;
	} else {
		printfln("lex error with character %c at position %d of line %d in file %s",
				this.getCurrentChar(),
				this.getCurrentIndexInLine(),
				this.getCurrentLineCount(),
				this.getFilename());
		assert(false, "Lex error");
	}
%}

"[:digit:][:digit:_]*" {: printfln("int %s", this.getCurrentLex()); :}
"0x[01234567][01234567_]*" {: printfln("hex %s", this.getCurrentLex()); :}
"0b[01][01_]*" {: printfln("bin %s", this.getCurrentLex()); :}
"long" {: printfln("long keyword"); :}
"if" {: printfln("if keyword"); :}
"for" {: printfln("for keyword"); :}
"while" {: printfln("while keyword"); :}
"do" {: printfln("do keyword"); :}
"int" {: printfln("int keyword"); :}
"void" {: printfln("void keyword"); :}
"delegate" {: printfln("delegate keyword"); :}
"function" {: printfln("function keyword"); :}
"template" {: printfln("template keyword"); :}
"[:alpha:][:word:]*" {: printfln("identifer"); :}
"\\"[:word: ]*\\"" {: printfln("string %s",this.getCurrentLex()); :}
"." {: printfln("dot"); :}
"(" {: printfln("left parenthies"); :}
")" {: printfln("right parenthies"); :}
"{" {: printfln("left brace"); :}
"}" {: printfln("right brace"); :}
" " {: printfln("blank"); :}
"\"" {: printfln("tick"); :}
